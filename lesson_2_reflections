1.- What happens when you initialize a repository? Why do you need to do it?


	A git file is created in the directory. You do it in order to be able to stage files and commit those files in the git repository. 


2.- How is the staging area different from the working directory and the repository? What value do you think it offers?

	The staging area is an intermediate area that allows you to keep control of files by only adding specific changes to files one by one.This give you more control of which files are being changed and which changes should be commited to master.  There are multiple cases where this could be useful: you may not be truly sure if you want to commit changes,  you want to compare files from the working directory o from the master,  you want to revise, o commit multiple files at the same time.


3.- How can you use the staging area to make sure you have one commit per logical change?

	The staging area can help you by adding small changes to your code. By specifying exactly what changes should be comitted and adding one file at a time, you make step by step logical chances; this makes your code easier to read and easier to maintain. 

4.- What are some situations when branches would be helpful in keeping your history organized? How would branches help?

	You may use branches to develop code simultaneously: debuggin, testing, new features. You can also use branches to track different milestones or different stages of your project and later on merge if it is necessary.  I think branches help agilize, experiment and develop faster and securely. 

5.- How do the diagrams help you visualize the branch structure?

	Similar to a timeline, it gives yous a birdseye view of your entire development process: changes, errors, milestones, commitments, and branches. You can visualize your current tip of the branch and the parent of each commit you have made, and have a mindmap of merged branches. 


6.- What is the result of merging two branches together? Why do we represent it in the diagram the way we do?

	Merging syncs the commits of both branches by combining both versions into one single master branch. the label of both branches gets deleted to form a new node with multiple parents;  This new master branch commit contains information of the history of each branch merged; Access to the history of the merged branches is possible since there is only one master branch and git commits are interleaved according to the date they were committed. It is represented that way in the diagram because it shows both parent branches merged into one; this means that the label gets deleted (signaled by both arrows meeting halfway into a new node instead of going unidirectional) 

7.- 


